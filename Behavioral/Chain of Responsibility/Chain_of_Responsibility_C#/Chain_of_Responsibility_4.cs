// Chain of Responsibility Design Pattern - Behavioural Category

// Motivation
//
// In writing an application of any kind, it often happens that the event generated by one object needs to be handled by another one.
// And, to make our work even harder, we also happen to be denied access to the object which needs to handle the event. 
// In this case there are two possibilities: there is the beginner/lazy approach of making everything public, creating reference 
// to every object and continuing from there and then there is the expert approach of using the Chain of Responsibility.

// The Chain of Responsibility design pattern allows an object to send a command without knowing what object will receive 
// and handle it. The request is sent from one object to another making them parts of a chain and each object in this chain can 
// handle the command, pass it on or do both. The most usual example of a machine using the Chain of Responsibility is the vending 
// machine coin slot: rather than having a slot for each type of coin, the machine has only one slot for all of them. 
// The dropped coin is routed to the appropriate storage place that is determined by the receiver of the command.

// Intent:
// - It avoids attaching the sender of a request to its receiver, giving this way other objects the possibility 
//   of handling the request too.
// - The objects become parts of a chain and the request is sent from one object to another across the chain until one 
//   of the objects handles it.

// Participants
// Handler - Defines an interface for handling requests
// RequestHandler - Handles the requests it is responsible for. If it can handle the request it does so, 
//                  otherwise it sends the request to its successor.
// Client - Sends commands to the first object in the chain that may handle the command.

// Here is how sending a request works in the application using the Chain of Responsibility: 
// the Client in need of a request to be handled sends it to the chain of handlers, which are classes that extend the Handler class. 
// Each of the handlers in the chain takes its turn at trying to handle the request it receives from the client. 
// If ConcreteHandler_i can handle it, then the request is handled, if not it is sent to the handler ConcreteHandler_i+1, 
// the next one in the chain.

// Applicability & Examples
//
// Having so many design patterns to choose from when writing an application, it's hard to decide on which one to use, 
// so here are a few situations when using the Chain of Responsibility is more effective:
// - More than one object can handle a command.
// - The handler is not known in advance.
// - The handler should be determined automatically.
// - It’s wished that the request is addressed to a group of objects without explicitly specifying its receiver.
// - The group of objects that may handle the command must be specified in a dynamic way.

// Hot points
// 
// The fundamental flaw of the pattern is the fact that it gets easily broken: if a programmer forgets to call the next handler 
// in the concreteHandler the request gets lost on the way. This problem comes from the fact that the execution is not handled 
// entirely by the superclass and the call is triggered in the superclass.
// When implementing the CoR pattern a special care should be taken for the request representation. 
// The request is not considered a distinctive part of the CoR pattern, but it is still used in all the components of the pattern.
// Another flaw of the Chain of Responsibility is the fact that some requests may end up unhandled due to the wrong implementation 
// of concrete handler, their propagation slowing down the rest of the application. This means that extra care is needed when 
// taking into account the requests that may appear in the process.

// http://www.oodesign.com/chain-of-responsibility-pattern.html

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

public class Request
{
    private int m_value;
    private String m_description;

    public Request(String description, int value)
    {
        m_description = description;
        m_value = value;
    }

    public int getValue()
    {
        return m_value;
    }

    public String getDescription()
    {
        return m_description;
    }
}


public abstract class Handler
{
    protected Handler m_successor;

    public void setSuccessor(Handler successor)
    {
        m_successor = successor;
    }

    public virtual void handleRequest(Request request)
    {
        m_successor.handleRequest(request);
    }
}


public class ConcreteHandlerOne : Handler
{
    public override void handleRequest(Request request)
    {
        if (request.getValue() < 0)
        {
            // If request is eligible, handle it.
            Console.WriteLine("Negative values are handled by {0}: ", this.GetType().Name);
            Console.WriteLine("\t{0} {1}: {2} ", this.GetType().Name, request.getDescription(), request.getValue());
        }
        else
        {
            base.handleRequest(request);
        }
    }
}


public class ConcreteHandlerThree : Handler
{
    public override void handleRequest(Request request)
    {
        if (request.getValue() == 0)
        {
            // If request is eligible handle it
            Console.WriteLine("Zero values are handled by {0}: ", this.GetType().Name);
            Console.WriteLine("\t{0} {1}: {2} ", this.GetType().Name, request.getDescription(), request.getValue());
        }
        else
        {
            base.handleRequest(request);
        }
    }
}

public class ConcreteHandlerTwo : Handler
{
    public override void handleRequest(Request request)
    {
        if (request.getValue() > 0)
        {
            // If request is eligible handle it
            Console.WriteLine("Positive values are handled by {0}: ", this.GetType().Name);
            Console.WriteLine("\t{0} {1}: {2} ", this.GetType().Name, request.getDescription(), request.getValue());
        }
        else
        {
            base.handleRequest(request);
        }
    }
}

public class MainApp
{
    static void Main(string[] args)
    {
        // Setup Chain of Responsibility
        Handler h1 = new ConcreteHandlerOne();
        Handler h2 = new ConcreteHandlerTwo();
        Handler h3 = new ConcreteHandlerThree();

        h1.setSuccessor(h2);
        h2.setSuccessor(h3);

        // Send requests to the chain
        h1.handleRequest(new Request("Negative Value", -1));
        h1.handleRequest(new Request("Zero Value", 0));
        h1.handleRequest(new Request("Positive Value", 1));
        h1.handleRequest(new Request("Positive Value", 2));
        h1.handleRequest(new Request("Negative Value", -5));

        Console.ReadKey();
    }
}